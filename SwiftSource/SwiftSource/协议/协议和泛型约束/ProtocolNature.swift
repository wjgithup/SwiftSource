
//
//  ProtocolNature.swift
//  SwiftSource
//
//  Created by 曾婷 on 2018/7/17.
//  Copyright © 2018年 王杰. All rights reserved.
//

import UIKit

//因为 f 接受的是泛型参数，整数 5 会被直接传递给这 个函数，而不需要经过任何包装。所以它的大小是 8 字节，也就是 64 位系统中 Int 的尺寸。对 于 g，整数会被封装到一个存在容器中。对于普通的协议 (也就是没有被约束为只能由 class 实 现的协议)，会使用不透明存在容器 (opaque existential container)。不透明存在容器中含有一 个存储值的缓冲区 (大小为三个指针，也就是 24 字节);一些元数据 (一个指针，8 字节);以及 若干个目击表 (0 个或者多个指针，每个 8 字节)。如果值无法放在缓冲区里，那么它将被存储到 堆上，缓冲区里将变为存储引用，它将指向值在堆上的地址。元数据里包含关于类型的信息 (比 如是否能够按条件进行类型转换等)。
//目击表是让动态派发成为可能的关键。它为一个特定的类型将协议的实现进行编码:对于协议 中的每个方法，表中会包含一个指向特定类型中的实现的入口。有时候这被称为 vtable

//存在容器为代码调用添加了一层非直接层，所以相对于泛型参数，一般来说都会造成性能降低 (假设编译器能够对泛型代码进行特化处理)。除了可能更慢的方法派发以外，存在容器还扮演了 阻止编译器优化的壁垒⻆色。大多数时候，担忧这里的性能其实是过早优化。但是，如果你想 要获取最大化的性能的时候，使用泛型参数确实要比使用协议类型高效得多。通过使用泛型参 数，你可以避免隐式的泛型封装。

func f<C: CustomStringConvertible>(_ x: C) -> Int {
    return MemoryLayout.size(ofValue: x)
}
func g(_ x: CustomStringConvertible) -> Int {
    return MemoryLayout.size(ofValue: x)
}

//f(5) // 8
//g(5) // 40

//如果你尝试将一个 [String] (或者其他任何类型) 传递给一个接受 [Any] (或者其他任意接受协议 类型，而非具体类型的数组) 的函数时，编译器将会插入代码对数组进行映射，将每个值都包装 起来。这将使方法调用本身成为一个 O(n) 的操作 (其中 n 是数组中的元素个数)，这还不包含 函数体的复杂度。同样的，大多数情况下这不会导致问题，但是如果你需要写高性能的代码， 你可能需要将你的函数写为泛型参数的形式，而不是使用协议类型:

//隐式打包
func printProtocol(array: [CustomStringConvertible]) {
    print(array)
}
//没有打包
func printGeneric<A: CustomStringConvertible>(array: [A]) {
    print(array)
}

//使用协议最大的好处在于它们提供了一种最小的实现接口。一个良好设计的协议会为我们指明 遵守该协议的类型所需要的最小要求，只要实现这个要求，协议就能够以被设计的算法方式运 作。同样，这也让测试变得更加容易。我们只需要创建一个满足协议的简单的测试类型就可以 开始测试工作了，而不必引入和建立一串复杂的依赖关系。

