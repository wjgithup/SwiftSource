//
//  Escaping.swift
//  SwiftSource
//
//  Created by 曾婷 on 2018/7/16.
//  Copyright © 2018年 王杰. All rights reserved.
//

import UIKit

//  一个被保存在某个地方等待稍后 (比如函数返回以后) 再调用的闭包就叫做逃逸闭包。而传递给 map 的闭包会在 map 中被直接使用。

//  注意默认非逃逸的规则只对函数参数，以及那些直接参数位置 (immediate parameter position) 的函数类型有效。也就是说，如果一个存储属性的类型是函数的话，那么它将会是逃 逸的 (这很正常)。出乎意料的是，对于那些使用闭包作为参数的函数，如果闭包被封装到像是 多元组或者可选值等类型的话，这个闭包参数也是逃逸的。因为在这种情况下闭包不是直接参 数，它将自动变为逃逸闭包。这样的结果是，你不能写出一个函数，使它接受的函数参数同时 满足可选值和非逃逸。很多情况下，你可以通过为闭包提供一个默认值来避免可选值。如果这 样做行不通的话，可以通过重载函数，提供一个包含可选值 (逃逸) 的函数，以及一个不可选， 不逃逸的函数来绕过这个限制
